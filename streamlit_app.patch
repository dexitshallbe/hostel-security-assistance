diff --git a/streamlit_app.py b/streamlit_app.py
index c01c8d5a5f07071ea7264dc6c93d8caa79e89ec7..a6cbf4413bd590d7fe949d877f7a4625b01aff3c 100644
--- a/streamlit_app.py
+++ b/streamlit_app.py
@@ -1,47 +1,51 @@
 # streamlit_app.py
 # LAN-only Streamlit dashboard with:
 # - bcrypt password hashing
 # - brute-force lockout
 # - session-based "authed" flag (per browser session)
 # - real-time alerts + logs + evidence images
 # - ignore/dealt actions (ignore => false_alert=1)
 # - temporary guest upload with expiry (hours) + worker reload flag
 
 import os
+import re
 import shutil
 import sqlite3
 import subprocess
 import uuid
 from datetime import datetime, timedelta
+from typing import Optional, Tuple
 
 import bcrypt
+import cv2
 import streamlit as st
 from streamlit_autorefresh import st_autorefresh
 
 from src.config import Config
 from src.db.queries import (
+    add_entry_decision,
     add_log,
     get_open_alerts,
     get_recent_logs,
     update_alert_status,
 )
 from src.db.schema import init_db
 
 # ---------------------------
 # Paths / config
 # ---------------------------
 CFG = Config()
 DB_PATH = CFG.log_db_path
 GUESTS_ROOT = CFG.guests_dir
 RELOAD_FLAG = CFG.guests_reload_flag
 
 # ---------------------------
 # LAN-only demo auth config
 # ---------------------------
 DEMO_USER = "admin"
 
 # Generate once, then paste here:
 # python -c "import bcrypt; print(bcrypt.hashpw(b'demo123', bcrypt.gensalt()).decode())"
 # NOTE: must be bytes: b"..."
 DEMO_PASS_HASH = b"$2b$12$4hpLku0pTKn8lgXXFSmMa.qPL59Py8RH.PwsenY9x/OXFNMamS/36"
 
@@ -49,50 +53,64 @@ MAX_FAILS = 5
 LOCKOUT_MINUTES = 10
 
 # Auto refresh dashboard every N ms
 AUTO_REFRESH_MS = 2000
 
 PAGE_OPTIONS = ["Alerts", "Real-time Log", "Temp Guest Upload"]
 
 
 def touch_reload_flag():
     os.makedirs(GUESTS_ROOT, exist_ok=True)
     os.makedirs(os.path.dirname(RELOAD_FLAG), exist_ok=True)
     with open(RELOAD_FLAG, "a") as f:
         f.write("")
     os.utime(RELOAD_FLAG, None)
 
 
 def _init_session():
     if "authed" not in st.session_state:
         st.session_state.authed = False
     if "fail_count" not in st.session_state:
         st.session_state.fail_count = 0
     if "locked_until" not in st.session_state:
         st.session_state.locked_until = None
     if "selected_page" not in st.session_state:
         st.session_state.selected_page = "Alerts"
+    if "active_alert_id" not in st.session_state:
+        st.session_state.active_alert_id = None
+    if "deal_step" not in st.session_state:
+        st.session_state.deal_step = None
+    if "deal_submit_inflight" not in st.session_state:
+        st.session_state.deal_submit_inflight = False
+    if "granted_name_for_guest" not in st.session_state:
+        st.session_state.granted_name_for_guest = ""
+
+
+def _reset_deal_flow():
+    st.session_state.active_alert_id = None
+    st.session_state.deal_step = None
+    st.session_state.deal_submit_inflight = False
 
 
 def _is_locked() -> bool:
     locked_until = st.session_state.locked_until
     if locked_until is None:
         return False
     return datetime.now() < locked_until
 
 
 def _lock_remaining_minutes() -> int:
     locked_until = st.session_state.locked_until
     if locked_until is None:
         return 0
     seconds = (locked_until - datetime.now()).total_seconds()
     return max(0, int(seconds // 60) + 1)
 
 
 def check_login() -> bool:
     _init_session()
 
     if st.session_state.authed:
         return True
 
     st.title("Hostel Security Login")
 
@@ -139,135 +157,300 @@ def check_login() -> bool:
                 add_log(DB_PATH, "WARN", f"Login failed. Attempts left: {remaining}")
                 st.error(f"Invalid credentials. Attempts left: {remaining}")
 
     return False
 
 
 def render_sidebar():
     with st.sidebar:
         st.write("✅ Logged in")
         st.caption("LAN-only mode (bcrypt + lockout)")
 
         st.session_state.selected_page = st.radio(
             "Navigation",
             PAGE_OPTIONS,
             index=PAGE_OPTIONS.index(st.session_state.get("selected_page", "Alerts")),
         )
 
         st.code(DB_PATH)
 
         if st.button("Logout"):
             st.session_state.authed = False
             add_log(DB_PATH, "INFO", "Dashboard logout")
             st.rerun()
 
 
+def _extract_bbox_from_message(message: Optional[str]) -> Optional[Tuple[int, int, int, int]]:
+    if not message:
+        return None
+
+    # Accepts patterns like "bbox=(x1,y1,x2,y2)" / "bbox:[x1, y1, x2, y2]"
+    m = re.search(r"bbox\s*[:=]\s*[\[(]?\s*(-?\d+)\D+(-?\d+)\D+(-?\d+)\D+(-?\d+)", message, re.IGNORECASE)
+    if not m:
+        return None
+
+    try:
+        x1, y1, x2, y2 = (int(m.group(i)) for i in range(1, 5))
+        if x2 > x1 and y2 > y1:
+            return x1, y1, x2, y2
+    except Exception:
+        return None
+    return None
+
+
+def _annotate_image(frame_bgr, bbox: Optional[Tuple[int, int, int, int]], text: str, color=(0, 255, 255)):
+    out = frame_bgr.copy()
+    if bbox is not None:
+        x1, y1, x2, y2 = bbox
+        cv2.rectangle(out, (x1, y1), (x2, y2), color, 2)
+        cv2.putText(out, text, (x1, max(20, y1 - 8)), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2, cv2.LINE_AA)
+    else:
+        cv2.putText(out, text, (12, 24), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2, cv2.LINE_AA)
+    return out
+
+
+def _save_granted_annotated_snapshot(alert: dict, granted_name: str) -> str:
+    evidence_path = alert.get("evidence_path")
+    if not evidence_path or not os.path.exists(evidence_path):
+        raise FileNotFoundError("Evidence image for alert is missing on disk.")
+
+    frame = cv2.imread(evidence_path)
+    if frame is None:
+        raise ValueError("Could not read evidence image for annotation.")
+
+    bbox = _extract_bbox_from_message(alert.get("message"))
+    label = f"ENTRY_GRANTED {granted_name}".strip()
+    ann = _annotate_image(frame, bbox, label)
+
+    out_dir = os.path.join(CFG.log_images_dir, "granted")
+    os.makedirs(out_dir, exist_ok=True)
+    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
+    out_path = os.path.join(out_dir, f"alert_{int(alert['id'])}_entry_granted_{ts}_ann.jpg")
+    cv2.imwrite(out_path, ann)
+    return out_path
+
+
+def _resolve_entry_denied(alert_id: int):
+    with sqlite3.connect(DB_PATH) as con:
+        con.execute("BEGIN")
+        con.execute("UPDATE alerts SET status=?, false_alert=? WHERE id=?", ("dealt", 0, int(alert_id)))
+        add_entry_decision(con=con, alert_id=int(alert_id), decision="ENTRY_DENIED")
+        con.commit()
+
+
+def _resolve_entry_granted(alert: dict, name: str, contact: str, address: str, reason: str, notes: str):
+    image_path = _save_granted_annotated_snapshot(alert, name)
+
+    with sqlite3.connect(DB_PATH) as con:
+        con.execute("BEGIN")
+        add_entry_decision(
+            con=con,
+            alert_id=int(alert["id"]),
+            decision="ENTRY_GRANTED",
+            name=name,
+            contact=contact or None,
+            address=address or None,
+            reason=reason or None,
+            notes=notes or None,
+            image_path=image_path,
+        )
+        con.execute("UPDATE alerts SET status=?, false_alert=? WHERE id=?", ("dealt", 0, int(alert["id"])))
+        con.commit()
+
+
 def render_alerts():
     st.subheader("Real-time Alerts (Open)")
+    st.caption("Dealt flow: choose Entry denied or Entry granted. Entry granted requires visitor details.")
     alerts = get_open_alerts(DB_PATH, limit=30)
 
     if not alerts:
         st.info("No open alerts right now.")
         return
 
     for a in alerts:
         with st.container(border=True):
             st.write(f"**[{a['alert_type']}]** camera=`{a['camera']}`  time=`{a['ts']}`")
 
             meta_cols = st.columns(3)
             with meta_cols[0]:
                 if a.get("name"):
                     st.write(f"name: `{a['name']}`")
             with meta_cols[1]:
                 if a.get("sim") is not None:
                     try:
                         st.write(f"sim: `{float(a['sim']):.3f}`")
                     except Exception:
                         st.write(f"sim: `{a['sim']}`")
             with meta_cols[2]:
                 if a.get("face_prob") is not None:
                     try:
                         st.write(f"face_prob: `{float(a['face_prob']):.2f}`")
                     except Exception:
                         st.write(f"face_prob: `{a['face_prob']}`")
 
             if a.get("message"):
                 st.write(a["message"])
 
             # Evidence image
             ep = a.get("evidence_path")
             if ep and os.path.exists(ep):
                 st.image(ep, caption="Evidence", use_container_width=True)
             elif ep:
                 st.caption("Evidence path stored, but file not found on disk.")
 
             c1, c2 = st.columns(2)
 
             # Ignore => keep logs + evidence but tag false_alert=1
             if c1.button("Ignore (False alert)", key=f"ign_{a['id']}"):
                 update_alert_status(DB_PATH, int(a["id"]), status="ignored", false_alert=1)
                 add_log(DB_PATH, "INFO", f"Alert {a['id']} ignored (false_alert=1)")
                 st.rerun()
 
-            # Dealt => resolved
+            # Dealt => branch to entry resolution chooser
             if c2.button("Dealt", key=f"deal_{a['id']}"):
-                update_alert_status(DB_PATH, int(a["id"]), status="dealt", false_alert=0)
-                add_log(DB_PATH, "INFO", f"Alert {a['id']} marked dealt")
+                st.session_state.active_alert_id = int(a["id"])
+                st.session_state.deal_step = "choose_resolution"
                 st.rerun()
 
+            active_here = st.session_state.get("active_alert_id") == int(a["id"])
+            step = st.session_state.get("deal_step") if active_here else None
+            inflight = st.session_state.get("deal_submit_inflight", False)
+
+            if step == "choose_resolution":
+                st.info("Select final resolution for this alert.")
+                rc1, rc2, rc3 = st.columns(3)
+
+                if rc1.button("Entry denied", key=f"entry_denied_{a['id']}", disabled=inflight):
+                    st.session_state.deal_submit_inflight = True
+                    try:
+                        _resolve_entry_denied(int(a["id"]))
+                        add_log(DB_PATH, "INFO", f"Alert {a['id']} resolved as ENTRY_DENIED")
+                        _reset_deal_flow()
+                        st.success("Alert resolved: ENTRY_DENIED")
+                    except Exception as e:
+                        st.error(f"Failed to save ENTRY_DENIED decision: {e}")
+                        st.session_state.deal_submit_inflight = False
+                    st.rerun()
+
+                if rc2.button("Entry granted", key=f"entry_granted_{a['id']}", disabled=inflight):
+                    st.session_state.deal_step = "granted_form"
+                    st.rerun()
+
+                if rc3.button("Cancel", key=f"cancel_resolution_{a['id']}"):
+                    _reset_deal_flow()
+                    st.rerun()
+
+            if step == "granted_form":
+                with st.expander("Entry granted details", expanded=True):
+                    st.caption("Name is required. Reason is optional but recommended.")
+                    with st.form(f"entry_granted_form_{a['id']}"):
+                        v_name = st.text_input("Name *", key=f"grant_name_{a['id']}")
+                        v_contact = st.text_input("Contact", key=f"grant_contact_{a['id']}")
+                        v_address = st.text_area("Address", key=f"grant_address_{a['id']}")
+                        v_reason = st.text_area("Reason for entry", key=f"grant_reason_{a['id']}")
+                        v_notes = st.text_area("Notes", key=f"grant_notes_{a['id']}")
+                        gc1, gc2 = st.columns(2)
+                        submit = gc1.form_submit_button("Save entry granted", disabled=inflight)
+                        cancel = gc2.form_submit_button("Cancel")
+
+                    if cancel:
+                        _reset_deal_flow()
+                        st.rerun()
+
+                    if submit:
+                        if not (v_name or "").strip():
+                            st.error("Name is required for Entry granted.")
+                        else:
+                            st.session_state.deal_submit_inflight = True
+                            try:
+                                _resolve_entry_granted(
+                                    alert=a,
+                                    name=v_name.strip(),
+                                    contact=v_contact.strip(),
+                                    address=v_address.strip(),
+                                    reason=v_reason.strip(),
+                                    notes=v_notes.strip(),
+                                )
+                                add_log(DB_PATH, "INFO", f"Alert {a['id']} resolved as ENTRY_GRANTED for {v_name.strip()}")
+                                st.session_state.granted_name_for_guest = v_name.strip()
+                                st.session_state.deal_step = "guest_prompt"
+                                st.session_state.deal_submit_inflight = False
+                                st.rerun()
+                            except Exception as e:
+                                st.session_state.deal_submit_inflight = False
+                                st.error(f"Failed to save Entry granted details: {e}")
+
+            if step == "guest_prompt":
+                st.success("Entry granted saved successfully.")
+                st.write("Add this person as a guest for faster recognition next time?")
+                pc1, pc2 = st.columns(2)
+
+                if pc1.button("Yes", key=f"guest_yes_{a['id']}"):
+                    st.session_state.prefill_guest_name = st.session_state.get("granted_name_for_guest", "")
+                    st.session_state.selected_page = "Temp Guest Upload"
+                    _reset_deal_flow()
+                    st.rerun()
+
+                if pc2.button("No", key=f"guest_no_{a['id']}"):
+                    _reset_deal_flow()
+                    st.rerun()
+
 
 def render_logs():
     st.subheader("Live Text Logs")
     logs = get_recent_logs(DB_PATH, limit=200)
 
     if not logs:
         st.info("No logs yet.")
         return
 
     # Show newest first
     for l in logs[:80]:
         ts = l.get("ts", "")
         level = l.get("level", "")
         msg = l.get("message", "")
 
         if level == "ALERT":
             st.error(f"{ts} [{level}] {msg}")
         elif level == "WARN":
             st.warning(f"{ts} [{level}] {msg}")
         else:
             st.write(f"{ts} [{level}] {msg}")
 
 
 def render_guest_upload():
     st.subheader("Temporary Guest Access (Video)")
     st.caption(
         "Upload a short face-pose video for a temporary guest. "
         "We’ll extract face crops automatically and grant access for the chosen duration."
     )
 
+    if st.session_state.get("prefill_guest_name") and "guest_name_input" not in st.session_state:
+        st.session_state.guest_name_input = st.session_state.prefill_guest_name
+
     with st.form("guest_form"):
-        guest_name = st.text_input("Guest name")
+        guest_name = st.text_input("Guest name", key="guest_name_input")
         hours = st.number_input("Access duration (hours)", min_value=1, max_value=168, value=24)
         video = st.file_uploader(
             "Upload pose video (mp4/mov/avi/mkv)", type=["mp4", "mov", "avi", "mkv"], accept_multiple_files=False
         )
         submitted = st.form_submit_button("Add guest")
 
     if not submitted:
         return
 
     if not guest_name:
         st.error("Guest name is required.")
         return
     if video is None:
         st.error("Upload a video file.")
         return
 
     # Basic name sanitization to avoid weird folder names
     safe_name = "".join(c for c in guest_name.strip() if c.isalnum() or c in ("_", "-", " ")).strip().replace(" ", "_")
     if not safe_name:
         st.error("Guest name contains no usable characters.")
         return
 
     gid = str(uuid.uuid4())[:8]
     folder_name = f"{safe_name}__{gid}"
 
@@ -316,96 +499,98 @@ def render_guest_upload():
     produced = [p for p in os.listdir(final_folder) if p.lower().endswith((".jpg", ".jpeg", ".png"))]
     if len(produced) == 0:
         shutil.rmtree(final_folder, ignore_errors=True)
         add_log(DB_PATH, "WARN", f"No faces extracted for guest: {guest_name} id={gid}")
         st.error("No faces could be extracted from the video. Try a clearer/closer video.")
         return
 
     created = datetime.now()
     expires = created + timedelta(hours=int(hours))
 
     with sqlite3.connect(DB_PATH) as con:
         con.execute("""
         INSERT INTO guest_access(guest_id, name, created_ts, expires_ts, folder_path)
         VALUES(?,?,?,?,?)
         """, (
             gid,
             guest_name,
             created.isoformat(timespec="seconds"),
             expires.isoformat(timespec="seconds"),
             final_folder
         ))
 
     touch_reload_flag()
     add_log(DB_PATH, "INFO", f"Guest added: {guest_name} id={gid} faces={len(produced)} expires={expires.isoformat(timespec='seconds')}")
 
+    st.session_state.pop("prefill_guest_name", None)
     st.success(f"Guest '{guest_name}' added for {hours} hour(s). Faces extracted: {len(produced)} (id={gid})")
     st.rerun()
 
 
 def render_selected_page():
     selected_page = st.session_state.get("selected_page", "Alerts")
     if selected_page == "Alerts":
         st.title("Hostel Security Dashboard")
         st.caption("No live camera feed shown. Alerts are updated in real time.")
         render_alerts()
     elif selected_page == "Real-time Log":
         st.title("Hostel Security Dashboard")
         st.caption("No live camera feed shown. Text logs are updated in real time.")
         render_logs()
     elif selected_page == "Temp Guest Upload":
         st.title("Hostel Security Dashboard")
         st.caption("No live camera feed shown. Manage temporary guest uploads.")
         render_guest_upload()
 
+
 def apply_ui_polish():
     st.markdown(
         """
         <style>
         /* Add clean spacing */
         .block-container {
             padding-top: 1.5rem;
             padding-bottom: 2rem;
             max-width: 1200px;
         }
 
         /* Slightly nicer cards */
         div[data-testid="stVerticalBlockBorderWrapper"] {
             border-radius: 14px !important;
         }
 
         /* Buttons slightly rounded */
         .stButton > button,
         .stDownloadButton > button {
             border-radius: 12px !important;
             font-weight: 600;
         }
         </style>
         """,
         unsafe_allow_html=True,
     )
 
+
 def main():
     st.set_page_config(page_title="Hostel Security", layout="wide")
 
     # Ensure DB exists
     init_db(DB_PATH)
 
     _init_session()
 
     # Login gate
     if not check_login():
         return
 
     render_sidebar()
 
     # Auto refresh dashboard
     st_autorefresh(interval=AUTO_REFRESH_MS, key="dash_refresh")
 
     render_selected_page()
-    
-    apply_ui_polish()
 
+    apply_ui_polish()
 
 
 if __name__ == "__main__":
     main()
 
EOF
)
